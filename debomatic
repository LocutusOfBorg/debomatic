#!/usr/bin/env python

# Written by Luca Falavigna
# (C) 2007, Luca Falavigna

import os
import sha
from ConfigParser import ConfigParser
from re import findall
from sha import new
from sys import exit
from urllib import urlopen

conffile = '/etc/debomatic.conf'
defaultopts = ('packagedir', 'distribution', 'url')
Options = ConfigParser()

def parse_options(conffile, defaultopts):
	if not os.path.exists(conffile):
		print ('Configuration file %s does not exist' % conffile)
		sys.exit(0)
	Options.read(conffile)
	for opt in defaultopts:
		if not Options.has_option('default', opt) or \
		not Options.get('default', opt):
			print ('Please set "%s" in %s' % (opt, conffile))

def needs_update(url, directory, distribution):
	for component in distribution, distribution + '-backports', \
	distribution + '-security', distribution + '-updates':
		remote = urlopen('%s/dists/%s/Release.gpg' \
				 % (url, component)).read()
		if not os.path.exists(os.path.join(directory, 'gpg')):
			os.mkdir(os.path.join(directory, 'gpg'))
		gpgfile = os.path.join(directory, 'gpg', component)
		if not os.path.exists(gpgfile):
			return 'create'
		try:		
			fd = os.open(gpgfile, os.O_RDONLY)
		except:
			return 'create'
		remote_sha = new(remote)
		gpgfile_sha = new(os.read(fd, os.fstat(fd).st_size))
		os.close(fd)
		if remote_sha.digest() != gpgfile_sha.digest():
			return 'update'
	return None

def prepare_pbuilder(cmd, url, directory, distribution):
	cmdline = 'pbuilder %(cmd)s --basetgz %(directory)s/%(distribution)s \
		  --distribution %(distribution)s --override-config \
		  --othermirror " deb %(url)s %(distribution)s main \
		  restricted universe multiverse | deb %(url)s \
		  %(distribution)s-backports main restricted universe \
		  multiverse | deb %(url)s %(distribution)s-security main \
		  restricted universe multiverse | deb %(url)s \
		  %(distribution)s-updates main restricted universe \
		  multiverse" --buildplace %(directory)s/build \
		  --aptcache "%(directory)s/aptcache"' \
		  % {'cmd': cmd, 'url': url, 'directory': directory, \
		  'distribution': distribution}
	if not os.path.exists(os.path.join(directory, 'build')):
		os.mkdir(os.path.join(directory, 'build'))
	if not os.path.exists(os.path.join(directory, 'aptcache')):
		os.mkdir(os.path.join(directory, 'aptcache'))
	if (os.system(cmdline)):
		print 'pbuilder (%s) failed' % cmd
		exit(1)

def get_gpgfiles(url, directory, distribution):
	for component in distribution, distribution + '-backports', \
	distribution + '-security', distribution + '-updates':
		remote = urlopen('%s/dists/%s/Release.gpg' \
				 % (url, component)).read()
		if not os.path.exists(os.path.join(directory, 'gpg')):
			os.mkdir(os.path.join(directory, 'gpg'))
		gpgfile = os.path.join(directory, 'gpg', component)
		fd = os.open(gpgfile, os.O_WRONLY | os.O_CREAT, 0664)
		os.write(fd, remote)
		os.close(fd)

def setup_pbuilder(url, directory, distribution):
	result = needs_update(url, directory, distribution)
	if result:
		prepare_pbuilder(result, url, directory, distribution)
		get_gpgfiles(url, directory, distribution)

def select_dsc(directory):
	try:
		filelist = os.listdir(directory)
	except:
		print 'Unable to access directory %s' % directory
		exit(1)
	for filename in filelist:
		if os.path.splitext(filename)[1] == '.dsc':
			return filename
	return None

def parse_packages(directory, package):
	try:
		fd = os.open(os.path.join(directory, package), os.O_RDONLY)
	except:
		print 'Unable to open %s' % os.path.join(directory, package)
		exit(1)
	files =findall('\s\w+\s\d+\s(.*)', os.read(fd, os.fstat(fd).st_size))
	files.insert(len(files), package)
	os.close(fd)
	return files

def build_package(directory, packagelist, distribution):
	dscfile = None
	if not os.path.exists(os.path.join(directory, 'result')):
		os.mkdir(os.path.join(directory, 'result'))
	for package in packagelist:
		if os.path.exists(os.path.join(directory, package)):
			src = os.path.join(directory, package)
			dst = os.path.join(directory, 'work', package)
			os.renames(src, dst)
			if not dscfile:
				dscfile = findall('(.*\.dsc$)', dst)
	os.system('pbuilder build --basetgz %(directory)s/%(distribution)s \
		  --distribution %(distribution)s --override-config \
		  --buildplace %(directory)s/build \
		  --buildresult %(directory)s/result \
		  --aptcache %(directory)s/aptcache %(dsc)s' % \
		  {'distribution': distribution, \
		  'directory': directory, 'dsc': dscfile[0]})
	for package in packagelist:
		if os.path.exists(os.path.join(directory, 'work', package)):
			os.remove(os.path.join(directory, 'work', package))
