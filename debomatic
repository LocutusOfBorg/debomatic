#!/usr/bin/env python

# Written by Luca Falavigna
# (C) 2007, Luca Falavigna

import os
import sha
import sys
from ConfigParser import ConfigParser
from debomatic import daemon
from re import findall, split
from sha import new
from time import sleep, strftime
from urllib import urlopen

Options = ConfigParser()

class Log:
    def __init__(self, logfile):
        self.logfile = logfile

    def write(self, data):
        self.logfile.write(data)
        self.logfile.flush()

def parse_default_options():
    try:
        conffile = sys.argv[1]
    except:
        print 'Please specify a configuration file'
        sys.exit(-1)
    if not os.path.exists(conffile):
        print 'Configuration file %s does not exist' % conffile
        sys.exit(-1)
    Options.read(conffile)
    for opt in ('packagedir', 'logfile', 'sleep'):
        if not Options.has_option('default', opt) or \
        not Options.get('default', opt):
            print 'Please set "%s" in %s' % (opt, conffile)
            sys.exit(-1)

def parse_distribution_options(directory, package):
    options = dict()
    try:
        fd = os.open(os.path.join(directory, package), os.O_RDONLY)
    except:
        print 'Unable to open %s' % os.path.join(directory, package)
        sys.exit(-1)
    distro =findall('Distribution:\s+(.*)', os.read(fd, os.fstat(fd).st_size))
    os.close(fd)
    try:
        options['distribution'] = distro[0]
    except:
        print "Bad .changes file"
        sys.exit(-1)
    try:
        for opt in ('url', 'sections', 'components'):
            options[opt] = Options.get(options['distribution'], opt)
    except:
        print 'Not enabled for distribution %s' % options['distribution']
        sys.exit(-1)
    options['sections'] = split(',', options['sections'])
    return options

def select_package(directory):
    package = None
    priority = 0
    try:
        filelist = os.listdir(directory)
    except:
        print 'Unable to access directory %s' % directory
        sys.exit(-1)
    for filename in filelist:
        if os.path.splitext(filename)[1] == '.changes':
            curprio = get_priority(os.path.join(directory,filename))
            if curprio > priority:
                priority = curprio
                package = filename
    return package

def get_priority(changesfile):
    priority = 0
    priolist = {"low":1, "medium":2, "high":3}
    try:
        fd = os.open(changesfile, os.O_RDONLY)
    except:
        print 'Unable to open %s' % changesfile
        return 0
    urgency =findall('Urgency: (.*)', os.read(fd, os.fstat(fd).st_size))
    priority = priolist[urgency[0]] * 10000000000
    priority += 9999999999 - os.fstat(fd).st_mtime
    os.close(fd)
    return priority

def setup_pbuilder(directory, distopts):
    if not os.path.exists(os.path.join(directory)):
        os.mkdir(os.path.join(directory))
    result = needs_update(directory, distopts['url'], distopts['sections'])
    if result:
        prepare_pbuilder(result, directory, distopts)
        for section in distopts['sections']:
            remote = urlopen('%s/dists/%s/Release.gpg' \
                     % (distopts['url'], section)).read()
            if not os.path.exists(os.path.join(directory, 'gpg')):
                os.mkdir(os.path.join(directory, 'gpg'))
            gpgfile = os.path.join(directory, 'gpg', section)
            fd = os.open(gpgfile, os.O_WRONLY | os.O_CREAT, 0664)
            os.write(fd, remote)
            os.close(fd)

def needs_update(directory, url, sections):
    for section in sections:
        remote = urlopen('%s/dists/%s/Release.gpg' % (url, section)).read()
        if not os.path.exists(os.path.join(directory, 'gpg')):
            os.mkdir(os.path.join(directory, 'gpg'))
        gpgfile = os.path.join(directory, 'gpg', section)
        if not os.path.exists(gpgfile):
            return 'create'
        try:		
            fd = os.open(gpgfile, os.O_RDONLY)
        except:
            return 'create'
        remote_sha = new(remote)
        gpgfile_sha = new(os.read(fd, os.fstat(fd).st_size))
        os.close(fd)
        if remote_sha.digest() != gpgfile_sha.digest():
            return 'update'

def prepare_pbuilder(cmd, directory, distopts):
    repos = str()
    for section in distopts['sections']:
        repos += "deb %s %s %s | " % (distopts['url'], section, distopts['components'])
    if not os.path.exists(os.path.join(directory, 'build')):
        os.mkdir(os.path.join(directory, 'build'))
    if not os.path.exists(os.path.join(directory, 'aptcache')):
        os.mkdir(os.path.join(directory, 'aptcache'))
    if not os.path.exists(os.path.join(directory, 'logs')):
        os.mkdir(os.path.join(directory, 'logs'))
    if not os.path.exists(os.path.join(directory, 'work')):
        os.mkdir(os.path.join(directory, 'work'))
    if (os.system('pbuilder %(cmd)s --basetgz %(directory)s/%(distribution)s \
                  --distribution %(distribution)s --override-config \
                  --mirror %(url)s --othermirror "%(repository)s" \
                  --buildplace %(directory)s/build \
                  --aptcache "%(directory)s/aptcache" \
                  --logfile %(directory)s/logs/%(cmd)s.%(now)s' \
                  % {'cmd': cmd, 'directory': directory, \
                  'distribution': distopts['distribution'], \
                  'url': distopts['url'], 'repository': repos, \
                  'now': strftime('%Y%m%d_%H%M')})):
        print 'pbuilder (%s) failed' % cmd
        sys.exit(-1)

def build_package(directory, distdir, packagelist, distopts):
    dscfile = None
    if not os.path.exists(os.path.join(distdir, 'result')):
        os.mkdir(os.path.join(distdir, 'result'))
    for package in packagelist:
        if os.path.exists(os.path.join(directory, package)):
            src = os.path.join(directory, package)
            dst = os.path.join(distdir, 'work', package)
            os.renames(src, dst)
            if not dscfile:
                dscfile = findall('(.*\.dsc$)', dst)
    try:
        package = findall('.*/(.*).dsc$', dscfile[0])[0]
    except:
        package = None
    if not os.path.exists(os.path.join(distdir, 'result', package)):
        os.mkdir(os.path.join(distdir, 'result', package))
    os.system('pbuilder build --basetgz %(directory)s/%(distribution)s \
              --distribution %(distribution)s --override-config \
              --pkgname-logfile --buildplace %(directory)s/build \
              --buildresult %(directory)s/result/%(package)s \
              --mirror %(url)s --aptcache %(directory)s/aptcache %(dsc)s' % \
              {'distribution': distopts['distribution'], \
               'directory': distdir, 'url': distopts['url'], \
              'package': package, 'dsc': dscfile[0]})
    for package in packagelist:
        if os.path.exists(os.path.join(distdir, 'work', package)):
            os.remove(os.path.join(distdir, 'work', package))

def build_process():
    url = Options.get('default', 'url')
    directory = Options.get('default', 'packagedir')
    distribution = Options.get('default', 'distribution')
    package = select_package(directory)
    if package:
        distopts = parse_distribution_options(directory, package)
        try:
            fd = os.open(os.path.join(directory, package), os.O_RDONLY)
        except:
            print 'Unable to open %s' % os.path.join(directory, package)
            sys.exit(-1)
        files =findall('\s\w{32}\s\d+\s\w+\s[\w|-]+\s(.*)',
                       os.read(fd, os.fstat(fd).st_size))
        files.insert(len(files), package)
        os.close(fd)
        distdir = os.path.join(directory, distopts['distribution'])
        files = parse_packages(directory, package)
        build_package(directory, files, distribution)

def main():
    if os.getuid():
        print 'You must run deb-o-matic as root'
        sys.exit(-1)
    parse_default_options()
    daemon()
    sys.stdin.close()
    sys.stdout = sys.stderr = Log(open(Options.get('default', \
                                  'logfile'), 'a+'))
    while(1):
        pid = os.fork()
        if pid:
            os.waitpid(pid, 0)
            sleep(Options.getint('default', 'sleep'))
        else:
            build_process()
            sys.exit(0)

if __name__ == "__main__":
    main()
